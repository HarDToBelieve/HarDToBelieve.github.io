<dec f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/include/openssl/bn.h' l='787' type='BIGNUM * BN_mod_inverse(BIGNUM * out, const BIGNUM * a, const BIGNUM * n, BN_CTX * ctx)'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/include/openssl/bn.h' l='778'>// BN_mod_inverse sets |out| equal to |a|^-1, mod |n|. If |out| is NULL, a
// fresh BIGNUM is allocated. It returns the result or NULL on error.
//
// If |n| is even then the operation is performed using an algorithm that avoids
// some branches but which isn&apos;t constant-time. This function shouldn&apos;t be used
// for secret values; use |BN_mod_inverse_blinded| instead. Or, if |n| is
// guaranteed to be prime, use
// |BN_mod_exp_mont_consttime(out, a, m_minus_2, m, ctx, m_mont)|, taking
// advantage of Fermat&apos;s Little Theorem.</doc>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/dsa/dsa.c' l='692' u='c' c='DSA_do_check_signature'/>
<def f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/gcd.c' l='283' ll='326' type='BIGNUM * BN_mod_inverse(BIGNUM * out, const BIGNUM * a, const BIGNUM * n, BN_CTX * ctx)'/>
