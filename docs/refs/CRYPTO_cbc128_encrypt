<dec f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/modes/internal.h' l='327' type='void CRYPTO_cbc128_encrypt(const uint8_t * in, uint8_t * out, size_t len, const AES_KEY * key, uint8_t * ivec, block128_f block)'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/modes/internal.h' l='323'>// CRYPTO_cbc128_encrypt encrypts |len| bytes from |in| to |out| using the
// given IV and block cipher in CBC mode. The input need not be a multiple of
// 128 bits long, but the output will round up to the nearest 128 bit multiple,
// zero padding the input if needed. The IV will be updated on return.</doc>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/aes/mode_wrappers.c' l='103' u='c' c='AES_cbc_encrypt'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/e_aes.c' l='244' u='c' c='aes_cbc_cipher'/>
<def f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/modes/cbc.c' l='58' ll='100' type='void CRYPTO_cbc128_encrypt(const uint8_t * in, uint8_t * out, size_t len, const AES_KEY * key, uint8_t * ivec, block128_f block)'/>
