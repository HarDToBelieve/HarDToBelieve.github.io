<dec f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/modes/internal.h' l='92' type='void CRYPTO_ctr128_encrypt(const uint8_t * in, uint8_t * out, size_t len, const AES_KEY * key, uint8_t * ivec, uint8_t * ecount_buf, unsigned int * num, block128_f block)'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/cipher_extra/e_aesctrhmac.c' l='170' u='c' c='aead_aes_ctr_hmac_sha256_crypt'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/modes/internal.h' l='86'>// CRYPTO_ctr128_encrypt encrypts (or decrypts, it&apos;s the same in CTR mode)
// |len| bytes from |in| to |out| using |block| in counter mode. There&apos;s no
// requirement that |len| be a multiple of any value and any partial blocks are
// stored in |ecount_buf| and |*num|, which must be zeroed before the initial
// call. The counter is a 128-bit, big-endian value in |ivec| and is
// incremented by this function.</doc>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/aes/mode_wrappers.c' l='70' u='c' c='AES_ctr128_encrypt'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/e_aes.c' l='277' u='c' c='aes_ctr_cipher'/>
<def f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/modes/ctr.c' l='86' ll='124' type='void CRYPTO_ctr128_encrypt(const uint8_t * in, uint8_t * out, size_t len, const AES_KEY * key, uint8_t * ivec, uint8_t * ecount_buf, unsigned int * num, block128_f block)'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/modes/ctr.c' l='76'>// The input encrypted as though 128bit counter mode is being used.  The extra
// state information to record how much of the 128bit block we have used is
// contained in *num, and the encrypted counter is kept in ecount_buf.  Both
// *num and ecount_buf must be initialised with zeros before the first call to
// CRYPTO_ctr128_encrypt().
//
// This algorithm assumes that the counter is in the x lower bits of the IV
// (ivec), and that the application has full control over overflow and the rest
// of the IV.  This implementation takes NO responsibility for checking that
// the counter doesn&apos;t overflow into the rest of the IV when incremented.</doc>
