<dec f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/include/openssl/hkdf.h' l='35' type='int HKDF(uint8_t * out_key, size_t out_len, const EVP_MD * digest, const uint8_t * secret, size_t secret_len, const uint8_t * salt, size_t salt_len, const uint8_t * info, size_t info_len)'/>
<def f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/hkdf/hkdf.c' l='26' ll='40' type='int HKDF(uint8_t * out_key, size_t out_len, const EVP_MD * digest, const uint8_t * secret, size_t secret_len, const uint8_t * salt, size_t salt_len, const uint8_t * info, size_t info_len)'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/include/openssl/hkdf.h' l='25'>// HKDF.


// HKDF computes HKDF (as specified by RFC 5869) of initial keying material
// |secret| with |salt| and |info| using |digest|, and outputs |out_len| bytes
// to |out_key|. It returns one on success and zero on error.
//
// HKDF is an Extract-and-Expand algorithm. It does not do any key stretching,
// and as such, is not suited to be used alone to generate a key from a
// password.</doc>
