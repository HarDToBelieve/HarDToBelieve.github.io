<dec f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/include/openssl/pkcs8.h' l='85' type='X509_SIG * PKCS8_encrypt(int pbe_nid, const EVP_CIPHER * cipher, const char * pass, int pass_len, const uint8_t * salt, size_t salt_len, int iterations, PKCS8_PRIV_KEY_INFO * p8inf)'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pem/pem_pk8.c' l='135' u='c' c='do_pk8pkey'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/include/openssl/pkcs8.h' l='69'>// PKCS8_encrypt serializes and encrypts a PKCS8_PRIV_KEY_INFO with PBES1 or
// PBES2 as defined in PKCS #5. Only pbeWithSHAAnd128BitRC4,
// pbeWithSHAAnd3-KeyTripleDES-CBC and pbeWithSHA1And40BitRC2, defined in PKCS
// #12, and PBES2, are supported.  PBES2 is selected by setting |cipher| and
// passing -1 for |pbe_nid|.  Otherwise, PBES1 is used and |cipher| is ignored.
//
// |pass| is used as the password. If a PBES1 scheme from PKCS #12 is used, this
// will be converted to a raw byte string as specified in B.1 of PKCS #12. If
// |pass| is NULL, it will be encoded as the empty byte string rather than two
// zero bytes, the PKCS #12 encoding of the empty string.
//
// If |salt| is NULL, a random salt of |salt_len| bytes is generated. If
// |salt_len| is zero, a default salt length is used instead.
//
// The resulting structure is stored in an |X509_SIG| which must be freed by the
// caller.</doc>
<def f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/pkcs8_x509.c' l='232' ll='274' type='X509_SIG * PKCS8_encrypt(int pbe_nid, const EVP_CIPHER * cipher, const char * pass, int pass_len_in, const uint8_t * salt, size_t salt_len, int iterations, PKCS8_PRIV_KEY_INFO * p8inf)'/>
