<dec f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/include/openssl/rsa.h' l='320' type='int RSA_sign_pss_mgf1(RSA * rsa, size_t * out_len, uint8_t * out, size_t max_out, const uint8_t * digest, size_t digest_len, const EVP_MD * md, const EVP_MD * mgf1_md, int salt_len)'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/include/openssl/rsa.h' l='304'>// RSA_sign_pss_mgf1 signs |digest_len| bytes from |digest| with the public key
// from |rsa| using RSASSA-PSS with MGF1 as the mask generation function. It
// writes, at most, |max_out| bytes of signature data to |out|. The |max_out|
// argument must be, at least, |RSA_size| in order to ensure success. It returns
// 1 on success or zero on error.
//
// The |md| and |mgf1_md| arguments identify the hash used to calculate |digest|
// and the MGF1 hash, respectively. If |mgf1_md| is NULL, |md| is
// used.
//
// |salt_len| specifies the expected salt length in bytes. If |salt_len| is -1,
// then the salt length is the same as the hash length. If -2, then the salt
// length is maximal given the size of |rsa|. If unsure, use -1.
//
// WARNING: |digest| must be the result of hashing the data to be signed with
// |md|. Passing unhashed inputs will not result in a secure signature scheme.</doc>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_rsa.c' l='198' u='c' c='pkey_rsa_sign'/>
<def f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa.c' l='551' ll='572' type='int RSA_sign_pss_mgf1(RSA * rsa, size_t * out_len, uint8_t * out, size_t max_out, const uint8_t * digest, size_t digest_len, const EVP_MD * md, const EVP_MD * mgf1_md, int salt_len)'/>
