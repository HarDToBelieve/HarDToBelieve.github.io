<dec f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/include/openssl/rsa.h' l='382' type='int RSA_verify_pss_mgf1(RSA * rsa, const uint8_t * digest, size_t digest_len, const EVP_MD * md, const EVP_MD * mgf1_md, int salt_len, const uint8_t * sig, size_t sig_len)'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/include/openssl/rsa.h' l='367'>// RSA_verify_pss_mgf1 verifies that |sig_len| bytes from |sig| are a valid,
// RSASSA-PSS signature of |digest_len| bytes at |digest| by |rsa|. It returns
// one if the signature is valid and zero otherwise. MGF1 is used as the mask
// generation function.
//
// The |md| and |mgf1_md| arguments identify the hash used to calculate |digest|
// and the MGF1 hash, respectively. If |mgf1_md| is NULL, |md| is
// used. |salt_len| specifies the expected salt length in bytes.
//
// If |salt_len| is -1, then the salt length is the same as the hash length. If
// -2, then the salt length is recovered and all values accepted. If unsure, use
// -1.
//
// WARNING: |digest| must be the result of hashing the data to be verified with
// |md|. Passing unhashed input will not result in a secure signature scheme.</doc>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_rsa.c' l='221' u='c' c='pkey_rsa_verify'/>
<def f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa.c' l='627' ll='657' type='int RSA_verify_pss_mgf1(RSA * rsa, const uint8_t * digest, size_t digest_len, const EVP_MD * md, const EVP_MD * mgf1_md, int salt_len, const uint8_t * sig, size_t sig_len)'/>
