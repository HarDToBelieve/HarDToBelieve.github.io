<dec f='webkit/Source/WebKitLegacy/mac/WebView/WebViewData.h' l='135' type='bool LayerFlushController::flushLayers()'/>
<doc f='webkit/Source/WebKitLegacy/mac/WebView/WebViewData.h' l='134'>// FIXME: Rename to use &apos;updateRendering&apos; terminology.</doc>
<use f='webkit/Source/WebKitLegacy/mac/WebView/WebViewData.mm' l='138' u='c' c='_ZN26WebViewLayerFlushScheduler18layerFlushCallbackEv'/>
<def f='webkit/Source/WebKitLegacy/mac/WebView/WebView.mm' l='8842' ll='8865' type='bool LayerFlushController::flushLayers()'/>
<doc f='webkit/Source/WebKitLegacy/mac/WebView/WebView.mm' l='8808'>/*
    The order of events with compositing updates is this:

   Start of runloop                                        End of runloop
        |                                                       |
      --|-------------------------------------------------------|--
           ^         ^                                        ^
           |         |                                        |
    NSWindow update, |                                     CA commit
     NSView drawing  |
        flush        |
                layerSyncRunLoopObserverCallBack

    To avoid flashing, we have to ensure that compositing changes (rendered via
    the CoreAnimation rendering display link) appear on screen at the same time
    as content painted into the window via the normal WebCore rendering path.

    CoreAnimation will commit any layer changes at the end of the runloop via
    its &quot;CA commit&quot; observer. Those changes can then appear onscreen at any time
    when the display link fires, which can result in unsynchronized rendering.

    To fix this, the GraphicsLayerCA code in WebCore does not change the CA
    layer tree during style changes and layout; it stores up all changes and
    commits them via flushCompositingState(). There are then two situations in
    which we can call flushCompositingState():

    1. When painting. FrameView::paintContents() makes a call to flushCompositingState().

    2. When style changes/layout have made changes to the layer tree which do not
       result in painting. In this case we need a run loop observer to do a
       flushCompositingState() at an appropriate time. The observer will keep firing
       until the time is right (essentially when there are no more pending layouts).

*/</doc>
