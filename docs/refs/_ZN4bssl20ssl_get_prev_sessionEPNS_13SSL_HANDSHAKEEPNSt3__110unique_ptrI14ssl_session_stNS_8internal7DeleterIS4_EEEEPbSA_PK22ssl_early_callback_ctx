<dec f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/internal.h' l='3021' type='enum ssl_hs_wait_t bssl::ssl_get_prev_session(bssl::SSL_HANDSHAKE * hs, UniquePtr&lt;SSL_SESSION&gt; * out_session, bool * out_tickets_supported, bool * out_renew_ticket, const SSL_CLIENT_HELLO * client_hello)'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/internal.h' l='3015'>// ssl_get_prev_session looks up the previous session based on |client_hello|.
// On success, it sets |*out_session| to the session or nullptr if none was
// found. If the session could not be looked up synchronously, it returns
// |ssl_hs_pending_session| and should be called again. If a ticket could not be
// decrypted immediately it returns |ssl_hs_pending_ticket| and should also
// be called again. Otherwise, it returns |ssl_hs_error|.</doc>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/handshake_server.cc' l='864' u='c' c='_ZN4bsslL20do_select_parametersEPNS_13SSL_HANDSHAKEE'/>
<def f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_session.cc' l='711' ll='755' type='enum ssl_hs_wait_t bssl::ssl_get_prev_session(bssl::SSL_HANDSHAKE * hs, UniquePtr&lt;SSL_SESSION&gt; * out_session, bool * out_tickets_supported, bool * out_renew_ticket, const SSL_CLIENT_HELLO * client_hello)'/>
