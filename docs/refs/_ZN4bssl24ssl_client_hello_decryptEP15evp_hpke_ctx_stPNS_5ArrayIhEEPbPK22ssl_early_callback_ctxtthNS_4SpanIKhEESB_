<dec f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/internal.h' l='1494' type='bool bssl::ssl_client_hello_decrypt(EVP_HPKE_CTX * hpke_ctx, Array&lt;uint8_t&gt; * out_encoded_client_hello_inner, bool * out_is_decrypt_error, const SSL_CLIENT_HELLO * client_hello_outer, uint16_t kdf_id, uint16_t aead_id, uint8_t config_id, Span&lt;const uint8_t&gt; enc, Span&lt;const uint8_t&gt; payload)'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/internal.h' l='1488'>// ssl_client_hello_decrypt attempts to decrypt the given |payload| into
// |out_encoded_client_hello_inner|. The decrypted value should be an
// EncodedClientHelloInner. It returns false if any fatal errors occur and true
// otherwise, regardless of whether the decrypt was successful. It sets
// |out_encoded_client_hello_inner| to true if the decryption fails, and false
// otherwise.</doc>
<def f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/encrypted_client_hello.cc' l='268' ll='336' type='bool bssl::ssl_client_hello_decrypt(EVP_HPKE_CTX * hpke_ctx, Array&lt;uint8_t&gt; * out_encoded_client_hello_inner, bool * out_is_decrypt_error, const SSL_CLIENT_HELLO * client_hello_outer, uint16_t kdf_id, uint16_t aead_id, const uint8_t config_id, Span&lt;const uint8_t&gt; enc, Span&lt;const uint8_t&gt; payload)'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/handshake_server.cc' l='632' u='c' c='_ZN4bsslL20do_read_client_helloEPNS_13SSL_HANDSHAKEE'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc' l='652' u='c' c='_ZN4bsslL27do_read_second_client_helloEPNS_13SSL_HANDSHAKEE'/>
