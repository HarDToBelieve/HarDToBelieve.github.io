<dec f='webkit/Source/WebCore/page/EventHandler.h' l='310' type='void WebCore::EventHandler::sendFakeEventsAfterWidgetTracking(NSEvent * initiatingEvent)'/>
<dec f='webkit/WebKitBuild/Debug/WebCore.framework/Versions/A/PrivateHeaders/EventHandler.h' l='310' type='void WebCore::EventHandler::sendFakeEventsAfterWidgetTracking(NSEvent * initiatingEvent)'/>
<use f='webkit/Source/WebKitLegacy/mac/WebCoreSupport/PopupMenuMac.mm' l='238' u='c' c='_ZN12PopupMenuMac4showERKN7WebCore7IntRectEPNS0_9FrameViewEi'/>
<def f='webkit/Source/WebCore/page/mac/EventHandlerMac.mm' l='585' ll='645' type='void WebCore::EventHandler::sendFakeEventsAfterWidgetTracking(NSEvent * initiatingEvent)'/>
<doc f='webkit/Source/WebCore/page/mac/EventHandlerMac.mm' l='576'>/*
 A hack for the benefit of AK&apos;s PopUpButton, which uses the Carbon menu manager, which thus
 eats all subsequent events after it is starts its modal tracking loop.  After the interaction
 is done, this routine is used to fix things up.  When a mouse down started us tracking in
 the widget, we post a fake mouse up to balance the mouse down we started with. When a 
 key down started us tracking in the widget, we post a fake key up to balance things out.
 In addition, we post a fake mouseMoved to get the cursor in sync with whatever we happen to 
 be over after the tracking is done.
 */</doc>
