<dec f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/audio/audio_level.h' l='51' type='double webrtc::voe::AudioLevel::TotalEnergy() const'/>
<def f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/audio/audio_level.cc' l='45' ll='48' type='double webrtc::voe::AudioLevel::TotalEnergy() const'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/audio/audio_level.h' l='39'>// See the description for &quot;totalAudioEnergy&quot; in the WebRTC stats spec
  // (https://w3c.github.io/webrtc-stats/#dom-rtcaudiohandlerstats-totalaudioenergy)
  // In our implementation, the total audio energy increases by the
  // energy-equivalent of LevelFullRange() at the time of ComputeLevel(), rather
  // than the energy of the samples in that specific audio frame. As a result,
  // we may report a higher audio energy and audio level than the spec mandates.
  // TODO(https://crbug.com/webrtc/10784): We should either do what the spec
  // says or update the spec to match our implementation. If we want to have a
  // decaying audio level we should probably update both the spec and the
  // implementation to reduce the complexity of the definition. If we want to
  // continue to have decaying audio we should have unittests covering the
  // behavior of the decay.</doc>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/audio/audio_send_stream.cc' l='489' u='c' c='_ZNK6webrtc8internal15AudioSendStream8GetStatsEb'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/audio/channel_receive.cc' l='729' u='c' c='_ZNK6webrtc3voe12_GLOBAL__N_114ChannelReceive20GetTotalOutputEnergyEv'/>
