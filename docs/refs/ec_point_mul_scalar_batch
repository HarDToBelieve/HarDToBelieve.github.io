<dec f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/ec/internal.h' l='332' type='int ec_point_mul_scalar_batch(const EC_GROUP * group, EC_RAW_POINT * r, const EC_RAW_POINT * p0, const EC_SCALAR * scalar0, const EC_RAW_POINT * p1, const EC_SCALAR * scalar1, const EC_RAW_POINT * p2, const EC_SCALAR * scalar2)'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/ec/internal.h' l='314'>// ec_point_mul_scalar_batch sets |r| to |p0| * |scalar0| + |p1| * |scalar1| +
// |p2| * |scalar2|. |p2| may be NULL to skip that term.
//
// The inputs are treated as secret, however, this function leaks information
// about whether intermediate computations add a point to itself. Callers must
// ensure that discrete logs between |p0|, |p1|, and |p2| are uniformly
// distributed and independent of the scalars, which should be uniformly
// selected and not under the attackers control. This ensures the doubling case
// will occur with negligible probability.
//
// This function is not implemented for all curves. Add implementations as
// needed.
//
// TODO(davidben): This function does not use base point tables. For now, it is
// only used with the generic |EC_GFp_mont_method| implementation which has
// none. If generalizing to tuned curves, this may be useful. However, we still
// must double up to the least efficient input, so precomputed tables can only
// save table setup and allow a wider window size.</doc>
<def f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/ec/ec.c' l='1080' ll='1100' type='int ec_point_mul_scalar_batch(const EC_GROUP * group, EC_RAW_POINT * r, const EC_RAW_POINT * p0, const EC_SCALAR * scalar0, const EC_RAW_POINT * p1, const EC_SCALAR * scalar1, const EC_RAW_POINT * p2, const EC_SCALAR * scalar2)'/>
