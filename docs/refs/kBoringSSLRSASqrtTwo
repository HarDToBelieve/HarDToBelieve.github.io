<dec f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/internal.h' l='123' type='const uint64_t []'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/internal.h' l='122'>// This constant is exported for test purposes.</doc>
<def f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c' l='985' ll='1002' type='const uint64_t [32]'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c' l='1003' u='r'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c' l='1003' u='r'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c' l='1204' u='r' c='rsa_generate_key_impl'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c' l='939'>// kBoringSSLRSASqrtTwo is the BIGNUM representation of ⌊2²⁰⁴⁷×√2⌋. This is
// chosen to give enough precision for 4096-bit RSA, the largest key size FIPS
// specifies. Key sizes beyond this will round up.
//
// To calculate, use the following Haskell code:
//
// import Text.Printf (printf)
// import Data.List (intercalate)
//
// pow2 = 4095
// target = 2^pow2
//
// f x = x*x - (toRational target)
//
// fprime x = 2*x
//
// newtonIteration x = x - (f x) / (fprime x)
//
// converge x =
//   let n = floor x in
//   if n*n - target &lt; 0 &amp;&amp; (n+1)*(n+1) - target &gt; 0
//     then n
//     else converge (newtonIteration x)
//
// divrem bits x = (x `div` (2^bits), x `rem` (2^bits))
//
// bnWords :: Integer -&gt; [Integer]
// bnWords x =
//   if x == 0
//     then []
//     else let (high, low) = divrem 64 x in low : bnWords high
//
// showWord x = let (high, low) = divrem 32 x in printf &quot;TOBN(0x%08x, 0x%08x)&quot; high low
//
// output :: String
// output = intercalate &quot;, &quot; $ map showWord $ bnWords $ converge (2 ^ (pow2 `div` 2))
//
// To verify this number, check that n² &lt; 2⁴⁰⁹⁵ &lt; (n+1)², where n is value
// represented here. Note the components are listed in little-endian order. Here
// is some sample Python code to check:
//
//   &gt;&gt;&gt; TOBN = lambda a, b: a &lt;&lt; 32 | b
//   &gt;&gt;&gt; l = [ &lt;paste the contents of kSqrtTwo&gt; ]
//   &gt;&gt;&gt; n = sum(a * 2**(64*i) for i, a in enumerate(l))
//   &gt;&gt;&gt; n**2 &lt; 2**4095 &lt; (n+1)**2
//   True</doc>
