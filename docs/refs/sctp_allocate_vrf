<dec f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_pcb.h' l='688' type='struct sctp_vrf * sctp_allocate_vrf(int vrfid)'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_bsd_addr.c' l='648' u='c' c='sctp_init_vrf_list'/>
<def f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_pcb.c' l='205' ll='251' type='struct sctp_vrf * sctp_allocate_vrf(int vrf_id)'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_pcb.c' l='575' u='c' c='sctp_add_addr_to_vrf'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_pcb.c' l='160'>/*-
 * Addresses are added to VRF&apos;s (Virtual Router&apos;s). For BSD we
 * have only the default VRF 0. We maintain a hash list of
 * VRF&apos;s. Each VRF has its own list of sctp_ifn&apos;s. Each of
 * these has a list of addresses. When we add a new address
 * to a VRF we lookup the ifn/ifn_index, if the ifn does
 * not exist we create it and add it to the list of IFN&apos;s
 * within the VRF. Once we have the sctp_ifn, we add the
 * address to the list. So we look something like:
 *
 * hash-vrf-table
 *   vrf-&gt; ifn-&gt; ifn -&gt; ifn
 *   vrf    |
 *    ...   +--ifa-&gt; ifa -&gt; ifa
 *   vrf
 *
 * We keep these separate lists since the SCTP subsystem will
 * point to these from its source address selection nets structure.
 * When an address is deleted it does not happen right away on
 * the SCTP side, it gets scheduled. What we do when a
 * delete happens is immediately remove the address from
 * the master list and decrement the refcount. As our
 * addip iterator works through and frees the src address
 * selection pointing to the sctp_ifa, eventually the refcount
 * will reach 0 and we will delete it. Note that it is assumed
 * that any locking on system level ifn/ifa is done at the
 * caller of these functions and these routines will only
 * lock the SCTP structures as they add or delete things.
 *
 * Other notes on VRF concepts.
 *  - An endpoint can be in multiple VRF&apos;s
 *  - An association lives within a VRF and only one VRF.
 *  - Any incoming packet we can deduce the VRF for by
 *    looking at the mbuf/pak inbound (for BSD its VRF=0 :D)
 *  - Any downward send call or connect call must supply the
 *    VRF via ancillary data or via some sort of set default
 *    VRF socket option call (again for BSD no brainer since
 *    the VRF is always 0).
 *  - An endpoint may add multiple VRF&apos;s to it.
 *  - Listening sockets can accept associations in any
 *    of the VRF&apos;s they are in but the assoc will end up
 *    in only one VRF (gotten from the packet or connect/send).
 *
 */</doc>
