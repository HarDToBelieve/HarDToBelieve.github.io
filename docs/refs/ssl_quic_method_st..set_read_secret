<dec f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/include/openssl/ssl.h' l='3309' type='int (*)(SSL *, enum ssl_encryption_level_t, const SSL_CIPHER *, const uint8_t *, size_t)'/>
<offset>0</offset>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/include/openssl/ssl.h' l='3287'>// set_read_secret configures the read secret and cipher suite for the given
  // encryption level. It returns one on success and zero to terminate the
  // handshake with an error. It will be called at most once per encryption
  // level.
  //
  // BoringSSL will not release read keys before QUIC may use them. Once a level
  // has been initialized, QUIC may begin processing data from it. Handshake
  // data should be passed to |SSL_provide_quic_data| and application data (if
  // |level| is |ssl_encryption_early_data| or |ssl_encryption_application|) may
  // be processed according to the rules of the QUIC protocol.
  //
  // QUIC ACKs packets at the same encryption level they were received at,
  // except that client |ssl_encryption_early_data| (0-RTT) packets trigger
  // server |ssl_encryption_application| (1-RTT) ACKs. BoringSSL will always
  // install ACK-writing keys with |set_write_secret| before the packet-reading
  // keys with |set_read_secret|. This ensures the caller can always ACK any
  // packet it decrypts. Note this means the server installs 1-RTT write keys
  // before 0-RTT read keys.
  //
  // The converse is not true. An encryption level may be configured with write
  // secrets a roundtrip before the corresponding secrets for reading ACKs is
  // available.</doc>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls_method.cc' l='97' u='r' c='_ZN4bsslL18tls_set_read_stateEP6ssl_st22ssl_encryption_level_tNSt3__110unique_ptrINS_14SSLAEADContextENS_8internal7DeleterIS5_EEEENS_4SpanIKhEE'/>
