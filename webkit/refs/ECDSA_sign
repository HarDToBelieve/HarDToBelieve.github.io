<dec f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/include/openssl/ecdsa.h' l='79' type='int ECDSA_sign(int type, const uint8_t * digest, size_t digest_len, uint8_t * sig, unsigned int * sig_len, const EC_KEY * key)'/>
<def f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/ecdsa_extra/ecdsa_asn1.c' l='69' ll='100' type='int ECDSA_sign(int type, const uint8_t * digest, size_t digest_len, uint8_t * sig, unsigned int * sig_len, const EC_KEY * eckey)'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/include/openssl/ecdsa.h' l='65'>// ECDSA contains functions for signing and verifying with the Digital Signature
// Algorithm over elliptic curves.


// Signing and verifying.

// ECDSA_sign signs |digest_len| bytes from |digest| with |key| and writes the
// resulting signature to |sig|, which must have |ECDSA_size(key)| bytes of
// space. On successful exit, |*sig_len| is set to the actual number of bytes
// written. The |type| argument should be zero. It returns one on success and
// zero otherwise.
//
// WARNING: |digest| must be the output of some hash function on the data to be
// signed. Passing unhashed inputs will not result in a secure signature scheme.</doc>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ec.c' l='131' u='c' c='pkey_ec_sign'/>
