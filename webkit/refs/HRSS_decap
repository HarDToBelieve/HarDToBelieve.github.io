<dec f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/include/openssl/hrss.h' l='81' type='void HRSS_decap(uint8_t * out_shared_key, const struct HRSS_private_key * in_priv, const uint8_t * ciphertext, size_t ciphertext_len)'/>
<def f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/hrss/hrss.c' l='1964' ll='2083' type='void HRSS_decap(uint8_t * out_shared_key, const struct HRSS_private_key * in_priv, const uint8_t * ciphertext, size_t ciphertext_len)'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/include/openssl/hrss.h' l='75'>// HRSS_decap decrypts a session key from |ciphertext_len| bytes of
// |ciphertext|. If the ciphertext is valid, the decrypted key is written to
// |out_shared_key|. Otherwise the HMAC of |ciphertext| under a secret key (kept
// in |in_priv|) is written. If the ciphertext is the wrong length then it will
// leak which was done via side-channels. Otherwise it should perform either
// action in constant-time.</doc>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_key_share.cc' l='275' u='c' c='_ZN4bssl12_GLOBAL__N_114CECPQ2KeyShare6FinishEPNS_5ArrayIhEEPhNS_4SpanIKhEE'/>
