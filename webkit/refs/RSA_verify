<dec f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/include/openssl/rsa.h' l='363' type='int RSA_verify(int hash_nid, const uint8_t * digest, size_t digest_len, const uint8_t * sig, size_t sig_len, RSA * rsa)'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/include/openssl/rsa.h' l='348'>// RSA_verify verifies that |sig_len| bytes from |sig| are a valid,
// RSASSA-PKCS1-v1_5 signature of |digest_len| bytes at |digest| by |rsa|.
//
// The |hash_nid| argument identifies the hash function used to calculate
// |digest| and is embedded in the resulting signature in order to prevent hash
// confusion attacks. For example, it might be |NID_sha256|.
//
// It returns one if the signature is valid and zero otherwise.
//
// WARNING: this differs from the original, OpenSSL function which additionally
// returned -1 on error.
//
// WARNING: |digest| must be the result of hashing the data to be verified with
// |hash_nid|. Passing unhashed input will not result in a secure signature
// scheme.</doc>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_rsa.c' l='218' u='c' c='pkey_rsa_verify'/>
<def f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa.c' l='574' ll='625' type='int RSA_verify(int hash_nid, const uint8_t * digest, size_t digest_len, const uint8_t * sig, size_t sig_len, RSA * rsa)'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa.c' l='896' u='c' c='RSA_check_fips'/>
