<dec f='webkit/Source/JavaScriptCore/jit/GCAwareJITStubRoutine.h' l='182' type='Ref&lt;JSC::PolymorphicAccessJITStubRoutine&gt; JSC::createICJITStubRoutine(const MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; &amp; , FixedVector&lt;RefPtr&lt;JSC::AccessCase&gt;&gt; &amp;&amp; cases, FixedVector&lt;JSC::StructureID&gt; &amp;&amp; weakStructures, JSC::VM &amp; , const JSC::JSCell * owner, bool makesCalls, const Vector&lt;JSC::JSCell *&gt; &amp; , Bag&lt;JSC::CallLinkInfo&gt; &amp;&amp; callLinkInfos, JSC::CodeBlock * codeBlockForExceptionHandlers, JSC::DisposableCallSiteIndex exceptionHandlingCallSiteIndex)'/>
<doc f='webkit/Source/JavaScriptCore/jit/GCAwareJITStubRoutine.h' l='162'>// Helper for easily creating a GC-aware JIT stub routine. For the varargs,
// pass zero or more JSCell*&apos;s. This will either create a JITStubRoutine, a
// GCAwareJITStubRoutine, or an ObjectMarkingGCAwareJITStubRoutine as
// appropriate. Generally you only need to pass pointers that will be used
// after the first call to C++ or JS.
// 
// Ref&lt;PolymorphicAccessJITStubRoutine&gt; createICJITStubRoutine(
//    const MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt;&amp; code,
//    VM&amp; vm,
//    FixedVector&lt;RefPtr&lt;AccessCase&gt;&gt;&amp;&amp; cases,
//    const JSCell* owner,
//    bool makesCalls,
//    ...);
//
// Note that we don&apos;t actually use C-style varargs because that leads to
// strange type-related problems. For example it would preclude us from using
// our custom of passing &apos;0&apos; as NULL pointer. Besides, when I did try to write
// this function using varargs, I ended up with more code than this simple
// way.</doc>
<dec f='webkit/WebKitBuild/Debug/JavaScriptCore.framework/Versions/A/PrivateHeaders/GCAwareJITStubRoutine.h' l='182' type='Ref&lt;JSC::PolymorphicAccessJITStubRoutine&gt; JSC::createICJITStubRoutine(const MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; &amp; , FixedVector&lt;RefPtr&lt;JSC::AccessCase&gt;&gt; &amp;&amp; cases, FixedVector&lt;JSC::StructureID&gt; &amp;&amp; weakStructures, JSC::VM &amp; , const JSC::JSCell * owner, bool makesCalls, const Vector&lt;JSC::JSCell *&gt; &amp; , Bag&lt;JSC::CallLinkInfo&gt; &amp;&amp; callLinkInfos, JSC::CodeBlock * codeBlockForExceptionHandlers, JSC::DisposableCallSiteIndex exceptionHandlingCallSiteIndex)'/>
<doc f='webkit/WebKitBuild/Debug/JavaScriptCore.framework/Versions/A/PrivateHeaders/GCAwareJITStubRoutine.h' l='162'>// Helper for easily creating a GC-aware JIT stub routine. For the varargs,
// pass zero or more JSCell*&apos;s. This will either create a JITStubRoutine, a
// GCAwareJITStubRoutine, or an ObjectMarkingGCAwareJITStubRoutine as
// appropriate. Generally you only need to pass pointers that will be used
// after the first call to C++ or JS.
// 
// Ref&lt;PolymorphicAccessJITStubRoutine&gt; createICJITStubRoutine(
//    const MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt;&amp; code,
//    VM&amp; vm,
//    FixedVector&lt;RefPtr&lt;AccessCase&gt;&gt;&amp;&amp; cases,
//    const JSCell* owner,
//    bool makesCalls,
//    ...);
//
// Note that we don&apos;t actually use C-style varargs because that leads to
// strange type-related problems. For example it would preclude us from using
// our custom of passing &apos;0&apos; as NULL pointer. Besides, when I did try to write
// this function using varargs, I ended up with more code than this simple
// way.</doc>
