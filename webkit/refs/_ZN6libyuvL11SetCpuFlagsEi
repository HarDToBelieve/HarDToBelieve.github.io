<def f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/libyuv/include/libyuv/cpu_id.h' l='102' ll='109' type='void libyuv::SetCpuFlags(int cpu_flags)'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/libyuv/include/libyuv/cpu_id.h' l='86'>// Sets the CPU flags to |cpu_flags|, bypassing the detection code. |cpu_flags|
// should be a valid combination of the kCpuHas constants above and include
// kCpuInitialized. Use this method when running in a sandboxed process where
// the detection code might fail (as it might access /proc/cpuinfo). In such
// cases the cpu_info can be obtained from a non sandboxed process by calling
// InitCpuFlags() and passed to the sandboxed process (via command line
// parameters, IPC...) which can then call this method to initialize the CPU
// flags.
// Notes:
// - when specifying 0 for |cpu_flags|, the auto initialization is enabled
//   again.
// - enabling CPU features that are not supported by the CPU will result in
//   undefined behavior.
// TODO(fbarchard): consider writing a helper function that translates from
// other library CPU info to libyuv CPU info and add a .md doc that explains
// CPU detection.</doc>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/libyuv/source/cpu_id.cc' l='268' u='c' c='libyuv::MaskCpuFlags'/>
