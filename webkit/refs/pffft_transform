<dec f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/pffft/src/pffft.h' l='128' type='void pffft_transform(PFFFT_Setup * setup, const float * input, float * output, float * work, pffft_direction_t direction)'/>
<def f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/pffft/src/pffft.c' l='1875' ll='1877' type='void pffft_transform(PFFFT_Setup * setup, const float * input, float * output, float * work, pffft_direction_t direction)'/>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/third_party/pffft/src/pffft.h' l='110'>/*
   Perform a Fourier transform , The z-domain data is stored in the
   most efficient order for transforming it back, or using it for
   convolution. If you need to have its content sorted in the
   &quot;usual&quot; way, that is as an array of interleaved complex numbers,
   either use pffft_transform_ordered , or call pffft_zreorder after
   the forward fft, and before the backward fft.

   Transforms are not scaled: PFFFT_BACKWARD(PFFFT_FORWARD(x)) = N*x.
   Typically you will want to scale the backward transform by 1/N.

   The &apos;work&apos; pointer should point to an area of N (2*N for complex
   fft) floats, properly aligned. If &apos;work&apos; is NULL, then stack will
   be used instead (this is probably the best strategy for small
   FFTs, say for N &lt; 16384).

   input and output may alias.
*/</doc>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_processing/utility/pffft_wrapper.cc' l='104' u='c' c='_ZN6webrtc5Pffft16ForwardTransformERKNS0_11FloatBufferEPS1_b'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_processing/utility/pffft_wrapper.cc' l='119' u='c' c='_ZN6webrtc5Pffft17BackwardTransformERKNS0_11FloatBufferEPS1_b'/>
