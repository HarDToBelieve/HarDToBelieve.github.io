<def f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/task_utils/pending_task_safety_flag.h' l='117' ll='128'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/task_utils/to_queued_task.h' l='92' c='_ZN6webrtc12ToQueuedTaskERKNS_16ScopedTaskSafetyEOT_'/>
<size>8</size>
<doc f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/task_utils/pending_task_safety_flag.h' l='100'>// The ScopedTaskSafety makes using PendingTaskSafetyFlag very simple.
// It does automatic PTSF creation and signalling of destruction when the
// ScopedTaskSafety instance goes out of scope.
//
// ToQueuedTask has an overload that takes a ScopedTaskSafety too, so there
// is no need to explicitly call the &quot;flag&quot; method.
//
// Example usage:
//
//     my_task_queue-&gt;PostTask(ToQueuedTask(scoped_task_safety,
//        [this]() {
//             // task goes here
//        }
//
// This should be used by the class that wants tasks dropped after destruction.
// The requirement is that the instance has to be constructed and destructed on
// the same thread as the potentially dropped tasks would be running on.</doc>
<fun r='_ZN6webrtc16ScopedTaskSafetyC1Ev'/>
<fun r='_ZN6webrtc16ScopedTaskSafetyD1Ev'/>
<fun r='_ZNK6webrtc16ScopedTaskSafety4flagEv'/>
<mbr r='webrtc::ScopedTaskSafety::flag_' o='0' t='rtc::scoped_refptr&lt;PendingTaskSafetyFlag&gt;'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/regathering_controller.h' l='88'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/p2p_transport_channel.h' l='402'/>
<size>8</size>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtp_sender_egress.h' l='177'/>
<size>8</size>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/video/call_stats2.h' l='127'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/video/receive_statistics_proxy2.h' l='214'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/video/video_receive_stream2.h' l='293'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/call/call.cc' l='471'/>
<size>8</size>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/webrtc_voice_engine.h' l='263'/>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/webrtc_video_engine.h' l='555'/>
<size>8</size>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/usrsctp_transport.h' l='205'/>
<size>8</size>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/nack_module2.h' l='135'/>
<size>8</size>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/regathering_controller.cc' l='58' c='_ZN6webrtc26BasicRegatheringController44ScheduleRecurringRegatheringOnFailedNetworksEv'/>
<size>8</size>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.h' l='427'/>
<size>8</size>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/pc/peer_connection.h' l='645'/>
<size>8</size>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/memory/fifo_buffer.h' l='125'/>
<size>8</size>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/openssl_stream_adapter.h' l='208'/>
<size>8</size>
<use f='webkit/Source/ThirdParty/libwebrtc/Source/webrtc/video/video_stream_encoder.h' l='417'/>
<size>8</size>
<def f='webkit/WebKitBuild/Debug/usr/local/include/webrtc/rtc_base/task_utils/pending_task_safety_flag.h' l='117' ll='128'/>
<use f='webkit/WebKitBuild/Debug/usr/local/include/webrtc/rtc_base/task_utils/to_queued_task.h' l='92' c='_ZN6webrtc12ToQueuedTaskERKNS_16ScopedTaskSafetyEOT_'/>
<size>8</size>
<doc f='webkit/WebKitBuild/Debug/usr/local/include/webrtc/rtc_base/task_utils/pending_task_safety_flag.h' l='100'>// The ScopedTaskSafety makes using PendingTaskSafetyFlag very simple.
// It does automatic PTSF creation and signalling of destruction when the
// ScopedTaskSafety instance goes out of scope.
//
// ToQueuedTask has an overload that takes a ScopedTaskSafety too, so there
// is no need to explicitly call the &quot;flag&quot; method.
//
// Example usage:
//
//     my_task_queue-&gt;PostTask(ToQueuedTask(scoped_task_safety,
//        [this]() {
//             // task goes here
//        }
//
// This should be used by the class that wants tasks dropped after destruction.
// The requirement is that the instance has to be constructed and destructed on
// the same thread as the potentially dropped tasks would be running on.</doc>
<fun r='_ZN6webrtc16ScopedTaskSafetyC1Ev'/>
<fun r='_ZN6webrtc16ScopedTaskSafetyD1Ev'/>
<fun r='_ZNK6webrtc16ScopedTaskSafety4flagEv'/>
<mbr r='webrtc::ScopedTaskSafety::flag_' o='0' t='rtc::scoped_refptr&lt;PendingTaskSafetyFlag&gt;'/>
